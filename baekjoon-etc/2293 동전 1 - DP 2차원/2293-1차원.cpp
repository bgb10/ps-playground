/*
동전들의 가치의 합이 k인 경우의 수를 "i까지의 동전이 있을 때 가치의 합이 j 인 경우의 수"를 통해 쌓아올려서 푸는 dp 문제.

1. 이때 쌓아올리는 과정이 선형적이지 않을 수도 있고, 점화식의 관계를 나타내는 인자가 하나가 아닐 수도 있는 것에 항상 주의하자.
예를 들어, 지금은 dp 배열이 dp[i] 이지만 dp[i][j] 일수도 있다.
2. i와 j가 부분문제를 쪼갠 기준이라고 하더라도, dp 배열에는 꼭 2차원으로 들어가지 않아도 된다.
해당 문제에서는 가치의 합 j 만 dp 배열의 인덱스로 들어갔다. 즉 1차원 배열로도 해결할 수 있었다.
대신에 for문을 2차원으로 돌면서 이전 부분 문제를 참고하는 형태로 문제를 해결한다.

# 9095번 1,2,3 더하기 문제와 흡사하다. 한번 풀어보자.
# 문제가 이해가 안가는 경우 직접 그려보자.
*/

#include <bits/stdc++.h>
using namespace std;

int a[102];
int dp[10002];

int main() {
	ios::sync_with_stdio(0);
    cin.tie(0);
    int n, k;
    cin >> n >> k;
    for(int i=0; i<n; i++) {
        cin >> a[i];
    }
    dp[0] = 1;
    for(int i=0; i<n; i++) {
        for(int j=a[i]; j<=k; j++) {
            dp[j] += dp[j-a[i]];
        }
    }
    cout << dp[k];
	return 0;
}