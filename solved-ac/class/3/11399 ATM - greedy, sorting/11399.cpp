/*
그리디적인 사고를 하면 쉽게 풀 수 있는 문제. 허프만 코딩의 개념도 녹아들어가 있다.

줄의 앞에 인출 시간이 최대한 작은 사람이 와야 뒤의 사람이 기다리는 시간이 줄어든다.
식으로 따지면, 앞에서부터 기다리는 시간이 a b c 라고 할 때, a + (a + b) + (a + b + c) 가 기다리는 총 시간이다.
따라서 앞에 있는 사람의 시간이 가장 많이 합에 더해지게 되는데, 
이를 감안하면 인출 시간이 작은 사람부터 순서대로 나열하면 된다.

빈도나 가중치에 따라 대응되는 문자열의 길이를 반환하는 '허프만 코딩' 의 개념도 녹아있는 문제다.

#태그: #정렬, #허프만 코딩, #그리디
#연관문제: 1202 보석도둑
*/

#include <bits/stdc++.h>
using namespace std;

int main() {
	ios::sync_with_stdio(0);
    cin.tie(0);
    int n;
    cin >> n;
    int p[1002];
    for(int i=0; i<n; i++) {
        cin >> p[i];
    }
    sort(p, p+n);
    int ans = 0;
    int t = n;
    for(int i=0; i<n; i++) {
        ans += p[i] * (t--); 
    }
    cout << ans;
	return 0;
}