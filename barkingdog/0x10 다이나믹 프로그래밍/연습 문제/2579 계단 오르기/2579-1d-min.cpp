/*
2차원 dp 테이블을 역발상을 통해 1차원으로 풀이

"n번째 계단까지 밟았을 때 최대값"은 역으로 생각하면,
"전체 계단 - n번째 계단까지 밟지 않은 최소값"으로 생각할 수 있다.
n 번째 계단까지 밟지 않은 최소값을 구하기 위해 부분문제를 만들면 i 번째 계단까지 밟지 않은 최소값을 구하는 것이고,
이때 i 번째 계단은 반드시 밟지 않아야 한다. 
따라서 dp[1] = a[1], dp[2] = a[2] 이고,
연속해서 두 계단을 밟지 않을 수는 없으므로 i-1 번째 계단은 반드시 밟아야 한다.
i 번째 계단까지 밟지 않았을 때의 최소값은 i-2 번째 계단까지 밟지 않았을 때의 최소값과 i-3 번째 계단까지 밟지 않았을 떄의 최소값 중 최소값이다.
따라서 dp[i] = min(dp[i-2], dp[i-3]) 이다!

# 역발상을 통한 문제 해결
# 예시를 그려보면서 문제를 풀면 더 쉽게 풀 수 있다.
# 관점에 따라 dp 풀이를 달리할 수 있다!
*/

#include <bits/stdc++.h>
using namespace std;

int a[304];
int dp[304];

int main() {
	ios::sync_with_stdio(0);
    cin.tie(0);
    int n;
	cin >> n;
	int sum = 0;
	for(int i=1; i<=n; i++) {
		cin >> a[i];
		sum += a[i];
	}
	dp[1] = a[1];
	dp[2] = a[2];
	dp[3] = a[3];
	for(int i=4; i<=n; i++) {
		dp[i] = min(dp[i-2], dp[i-3]) + a[i];
	}
	cout << sum - min(dp[n-1], dp[n-2]);
	return 0;
}