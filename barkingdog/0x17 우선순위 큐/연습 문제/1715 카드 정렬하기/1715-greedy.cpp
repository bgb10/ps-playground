/*
그리디와 priority_queue 를 사용해서 푸는 문제.

그리디적인 접근을 하면, 매 순간마다 '최소 크기의 카드 묶음 2개를 선정'해서 합쳐나가야 한다.
만약 최소 크기가 아닌 카드 묶음 2개를 선정해서 합치고 또 다른 묶음과 비교하게 된다면, 큰 수가 여러번 더해지는 상황이
생기기 때문이다. 그렇다면 처음에 카드 묶음을 입력받고, 최소값 2개를 찾고, 이것들을 삭제해야 한다.
이를 효과적으로 해결할 수 있는 자료구조는 우선순위 큐이다. (삽입 O(lgN), 최소값 조회 O(1), 삭제 O(lgN))

# 그리디 문제는 직관이 중요하다. 문제를 풀 때 직관적으로 문제를 풀 방안이 떠오른다면, 그리디일 가능성이 높다.
# 이 문제는 '허프만 코딩' 의 핵심적인 아이디어와 맞닿아있는 문제이다. 허프만 코딩에서는 문자열 압축시 빈도가 낮은
부호에는 큰 크기를 할당하고, 빈도가 높은 부호에는 작은 크기를 할당한다. 해당 문제에서 허프만 코딩의 접근방식을 사용하면,
카드 묶음의 크기가 클 수록 적게 더해야 하기 때문에, 크기가 작은 것부터 더해나가면 된다.
# 해당 문제는 int 범위 안에 들어오지만, 큰 수가 있으면 항상 int 범위를 벗어나지 않는지 의심하자.
*/

#include <bits/stdc++.h>
using namespace std;

int main() {
    cin.tie(0);
    ios::sync_with_stdio(0);
    int n;
    cin >> n;
    priority_queue<int, vector<int>, greater<int>> PQ;  // 기본 값은 최대 힙이므로 최소 힙으로 변경
    int x;
    for (int i = 0; i < n; i++) {
        cin >> x;
        PQ.push(x);
    }
    int cnt = 0;
    while (PQ.size() != 1) {
        int a = PQ.top();
        PQ.pop();
        int b = PQ.top();
        PQ.pop();
        cnt += a + b;
        PQ.push(a + b);
    }
    cout << cnt;
    return 0;
}