/*
그리디로 해결할 수 있는 문제.

주어진 동전의 가치가 서로 배수 관계이기 때문에, 상대적으로 큰 동전은 작은 동전 여러 개를 묶은 효과가 난다.
즉, K에 대해 최대한 큰 동전으로 지불하면 동전 개수의 최소값을 구할 수 있다.
만약 K에 대해 최대한 큰 동전으로 지불하지 않아도 최소값이 된다고 하자.
그렇다면, 그 동전은 여러 작은 동전으로 나눠질 것이고, 이는 동전의 개수가 증가하는 결과를 낳으므로 모순이다.

# 직관에 의존해서 풀고, 나중에는 직관을 증명해보는 습관을 들이자. 그리디 문제를 푸는데 도움이 될 것이다.
# 해당 문제는 동전이 서로 배수 관계라서 그리디 풀이가 가능했다. 만약 배수 관계가 아니라면 어떻게 될까? (2293 동전 1 참조)
*/

#include <bits/stdc++.h>
using namespace std;

int coin[11];

int main() {
  ios::sync_with_stdio(0);
  cin.tie(0);
  int n, k;
  cin >> n >> k;
  for (int i = 0; i < n; i++) {
    cin >> coin[i];
  }
  int cnt = 0;
  for (int i = n - 1; i >= 0; i--) {
    if(k == 0) {
      break;
    }
    while(k - coin[i] >= 0) {
      k -= coin[i];
      cnt++;
    }
  }
  cout << cnt;
  return 0;
}